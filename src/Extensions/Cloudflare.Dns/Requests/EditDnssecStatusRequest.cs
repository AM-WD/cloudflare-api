using System.Runtime.Serialization;
using Newtonsoft.Json.Converters;

namespace AMWD.Net.Api.Cloudflare.Dns
{
	/// <summary>
	/// Represents a request to edit the DNSSEC (Domain Name System Security Extensions) status for a domain.
	/// </summary>
	public class EditDnssecStatusRequest
	{
		/// <summary>
		/// Initializes a new instance of the <see cref="EditDnssecStatusRequest"/> class.
		/// </summary>
		/// <param name="zoneId">The zone identifier.</param>
		public EditDnssecStatusRequest(string zoneId)
		{
			ZoneId = zoneId;
		}

		/// <summary>
		/// The zone identifier.
		/// </summary>
		public string ZoneId { get; set; }

		/// <summary>
		/// If <see langword="true"/>, multi-signer DNSSEC is enabled on the zone, allowing multiple providers to serve a DNSSEC-signed zone at the same time.
		/// </summary>
		/// <remarks>
		/// This is required for DNSKEY records (except those automatically generated by Cloudflare) to be added to the zone.
		/// <br/>
		/// See <see href="https://developers.cloudflare.com/dns/dnssec/multi-signer-dnssec/">Multi-signer DNSSEC</see> for details.
		/// </remarks>
		public bool? DnssecMultiSigner { get; set; }

		/// <summary>
		/// If <see langword="true"/>, allows Cloudflare to transfer in a DNSSEC-signed zone including signatures from an external provider, without requiring Cloudflare to sign any records on the fly.
		/// </summary>
		/// <remarks>
		/// Note that this feature has some limitations. See <see href="https://developers.cloudflare.com/dns/zone-setups/zone-transfers/cloudflare-as-secondary/setup/#dnssec">Cloudflare as Secondary</see> for details.
		/// </remarks>
		public bool? DnssecPresigned { get; set; }

		/// <summary>
		/// If <see langword="true"/>, enables the use of NSEC3 together with DNSSEC on the zone.
		/// </summary>
		/// <remarks>
		/// Combined with setting <see cref="DnssecPresigned"/> to <see langword="true"/>, this enables the use of NSEC3 records when transferring in from an external provider.
		/// If <see cref="DnssecPresigned"/> is instead set to <see langword="false"/> (default), NSEC3 records will be generated and signed at request time.
		/// </remarks>
		public bool? DnssecUseNsec3 { get; set; }

		/// <summary>
		/// Status of DNSSEC, based on user-desired state and presence of necessary records.
		/// </summary>
		public DnssecEditStatus? Status { get; set; }
	}

	/// <summary>
	/// Status of DNSSEC, based on user-desired state and presence of necessary records.
	/// </summary>
	[JsonConverter(typeof(StringEnumConverter))]
	public enum DnssecEditStatus
	{
		/// <summary>
		/// DNSSEC is enabled.
		/// </summary>
		[EnumMember(Value = "active")]
		Active = 1,

		/// <summary>
		/// DNSSEC is disabled.
		/// </summary>
		[EnumMember(Value = "disabled")]
		Disabled = 3,
	}
}
